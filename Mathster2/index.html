<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Readster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Sacramento'>
<link rel="stylesheet" href="./style.css">
<link rel="stylesheet" href="./animations.css">

</head>

<body>

<form>
  <div>
    <label>y</label>
    <input type="range" min="0" max="400" name="y"/>
  </div>
  <div>
    <label>w</label>
    <input type="range" min="0" max="400" name="w"/>
  </div>
  <div>
    <label>wTop</label>
    <input type="range" min="0" max="400" name="wTop"/>
  </div>
  <div>
    <label>wBottom</label>
    <input type="range" min="0" max="400" name="wBottom"/>
  </div>
  <div>
    <label>h1</label>
    <input type="range" min="0" max="400" name="h1"/>
  </div>
  <div>
    <label>h1a</label>
    <input type="range" min="0" max="400" name="h1a"/>
  </div>
  <div>
    <label>h2</label>
    <input type="range" min="0" max="400" name="h2"/>
  </div>
  <div>
    <label>h2a</label>
    <input type="range" min="0" max="400" name="h2a"/>
  </div>
  <div>
    <label>h3</label>
    <input type="range" min="0" max="400" name="h3"/>
  </div>
</form>
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg" width="400" height="400">
  <defs>
    <lineargradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:rgb(255,255,0); stop-opacity:1;"></stop>
      <stop offset="100%" style="stop-color:rgb(255,0,0); stop-opacity:1;"></stop>
    </lineargradient>
    <radialgradient id="mouth-gradient" cx="50%" cy="50%" r="100%" fx="50%" fy="0%">
      <stop offset="0%" style="stop-color: hsla(31,62%,10%, 1); stop-opacity:1;"></stop>
      <stop offset="100%" style="stop-color: hsla(31,62%,30%, 1); stop-opacity:1;"></stop>
    </radialgradient>
    <radialGradient id="head-gradient" cx="50%" cy="50%" r="100%">
      <stop offset="0%" style="stop-color: hsla(31,62%,65%, 1); stop-opacity: 1;"></stop>
      <stop offset="50%" style="stop-color: hsla(31,62%,55%, 1); stop-opacity: 1;"></stop>
    </radialGradient>
    <radialGradient id="inner-eye-gradient" cx="0%" cy="00%" r="75%" fx="10%" fy="10%">
      <stop offset="0%" style="stop-color: #444; stop-opacity: 1;"></stop>
      <stop offset="100%" style="stop-color: black; stop-opacity: 1;"></stop>
    </radialGradient>
    <radialGradient id="outer-eye-gradient" cx="50%" cy="25%" r="75%" fx="50%" fy="50%">
      <stop offset="0%" style="stop-color: white; stop-opacity: 1;"></stop>
      <stop offset="100%" style="stop-color: #ddd; stop-opacity: 1;">     </stop>
    </radialGradient>
    <filter id="gaussian" x="0" y="0">
      <feGaussianBlur in="SourceGraphic" stdDeviation="10"></feGaussianBlur>
    </filter>
    <filter id="shadow" x="0" y="0">
      <feDropShadow dx="0" dy="4" stdDeviation="0"></feDropShadow>
      <feComponentTransfer>
        <feFuncA type="linear" slope=".1"></feFuncA>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode></feMergeNode>
        <feMergeNode in="SourceGraphic"></feMergeNode>
      </feMerge>
    </filter>
    <filter id="shadow-bocca" x="0" y="0">
      <feDropShadow dx="0" dy="-4" stdDeviation="0"></feDropShadow>
      <feComponentTransfer>
        <feFuncA type="linear" slope=".1"></feFuncA>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode></feMergeNode>
        <feMergeNode in="SourceGraphic"></feMergeNode>
      </feMerge>
    </filter>
  </defs>
  <!-- /defs-->
  <!-- Face-->
  <circle class="face" cx="200" cy="200" r="200" fill="url(#head-gradient)"></circle>
  <!-- Eyes-->
  <g>
    <circle class="eye" cx="133.33333333333331" cy="177.77777777777777" r="58.82352941176471" fill="url(#outer-eye-gradient)" filter="url(#shadow)"></circle>
    <circle class="eye" cx="266.6666666666667" cy="177.77777777777777" r="58.82352941176471" fill="url(#outer-eye-gradient)" filter="url(#shadow)"></circle>
    <circle class="eye" cx="150" cy="177.77777777777777" r="16.666666666666668" fill="url(#inner-eye-gradient)"></circle>
    <circle class="eye" cx="250" cy="177.77777777777777" r="16.666666666666668" fill="url(#inner-eye-gradient)"></circle>
  </g>
  <!-- Eyebrows-->
  <g fill="none" stroke="hsla(31,62%,10%, 1)" stroke-width="20" filter="url=(#shadow-bocca)">
    <path class="eyebrow" d="M 170 90 Q 140 90 110 100"></path>
    <path class="eyebrow" d="M 230 90 Q 260 90 290 100"></path>
  </g>
  <!-- Mouth-->
  <clipPath id="mouth-clip">
    <path id="mouth"></path>
  </clipPath>
  <!-- Mouth BG-->
  <circle id="mouth-bg" cx="200" cy="200" r="200" clip-path="url(#mouth-clip)" fill="url(#mouth-gradient)" filter="url(#shadow-bocca)"></circle>
  <!-- Teeth-->
  <ellipse id="teeth" cx="200" cy="230" rx="120" ry="50" r="58.82352941176471" fill="#ccc" clip-path="url(#mouth-clip)" filter="url(#shadow-bocca)"></ellipse>
  <!-- Tongue-->
  <ellipse id="tongue" cx="200" cy="380" rx="80" ry="50" r="58.82352941176471" fill="#ed000033" clip-path="url(#mouth-clip)"></ellipse>
</svg>
<!-- partial -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.2/TweenMax.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.2/TimelineMax.min.js'></script><script  src="./script.js"></script>

</body>
<body>
  <div id ="myContainer">
  <div id ="myAnimation"></div>
</div><div id ="myContainer2">
  <div id ="myAnimation2"></div>
  </div>
  <div class="box1">
<p>Earned time: <b id="vTime">0</b> minutes</p>
     <p id="math"></p><p hidden id="answer"></p>
     <div1><label>
         <input id="fill" type="text" placeholder="Answer">
       </label>
     <button class="open-modal" onclick="compute()">Submit</button>
</div>
</body>


<script>

(function() {
  'use strict';

  var inNodeJS = typeof process !== 'undefined' && !process.browser;

  var request = function requestNotProvided() {
    throw new Error("The 'request' module is only available while running in Node.");
  };
  if(inNodeJS) { // This will get stripped out by Uglify, and Webpack will not include it
    request = require('request');
  }

  var supportsCORS = false;
  var inLegacyIE = false;
  try {
    var testXHR = new XMLHttpRequest();
    if (typeof testXHR.withCredentials !== 'undefined') {
      supportsCORS = true;
    } else {
      if ('XDomainRequest' in window) {
        supportsCORS = true;
        inLegacyIE = true;
      }
    }
  } catch (e) { }

  // Create a simple indexOf function for support
  // of older browsers.  Uses native indexOf if
  // available.  Code similar to underscores.
  // By making a separate function, instead of adding
  // to the prototype, we will not break bad for loops
  // in older browsers
  var indexOfProto = Array.prototype.indexOf;
  var ttIndexOf = function(array, item) {
    var i = 0, l = array.length;

    if (indexOfProto && array.indexOf === indexOfProto) {
      return array.indexOf(item);
    }

    for (; i < l; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  };

  /*
    Initialize with Tabletop.init( { key: '0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc' } )
      OR!
    Initialize with Tabletop.init( { key: 'https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc&output=html&widget=true' } )
      OR!
    Initialize with Tabletop.init('0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc')
  */

  var Tabletop = function(options) {
    // Make sure Tabletop is being used as a constructor no matter what.
    if(!this || !(this instanceof Tabletop)) {
      return new Tabletop(options);
    }

    if(typeof(options) === 'string') {
      options = { key : options };
    }

    this.callback = options.callback;
    this.error = options.error;
    this.wanted = options.wanted || [];
    this.key = options.key;
    this.simpleSheet = !!options.simpleSheet;
    this.parseNumbers = !!options.parseNumbers;
    this.wait = !!options.wait;
    this.reverse = !!options.reverse;
    this.postProcess = options.postProcess;
    this.debug = !!options.debug;
    this.query = options.query || '';
    this.orderby = options.orderby;
    this.endpoint = options.endpoint || 'https://spreadsheets.google.com';
    this.singleton = !!options.singleton;
    this.simpleUrl = !!(options.simpleUrl || options.simple_url); //jshint ignore:line
    this.authkey = options.authkey;
    this.sheetPrivacy = this.authkey ? 'private' : 'public'

    this.callbackContext = options.callbackContext;
    // Default to on, unless there's a proxy, in which case it's default off
    this.prettyColumnNames = typeof(options.prettyColumnNames) === 'undefined' ? !options.proxy : options.prettyColumnNames;

    if(typeof(options.proxy) !== 'undefined') {
      // Remove trailing slash, it will break the app
      this.endpoint = options.proxy.replace(/\/$/,'');
      this.simpleUrl = true;
      this.singleton = true;
      // Let's only use CORS (straight JSON request) when
      // fetching straight from Google
      supportsCORS = false;
    }

    this.parameterize = options.parameterize || false;

    if (this.singleton) {
      if (typeof(Tabletop.singleton) !== 'undefined') {
        this.log('WARNING! Tabletop singleton already defined');
      }
      Tabletop.singleton = this;
    }

    /* Be friendly about what you accept */
    if (/key=/.test(this.key)) {
      this.log('You passed an old Google Docs url as the key! Attempting to parse.');
      this.key = this.key.match('key=(.*?)(&|#|$)')[1];
    }

    if (/pubhtml/.test(this.key)) {
      this.log('You passed a new Google Spreadsheets url as the key! Attempting to parse.');
      this.key = this.key.match('d\\/(.*?)\\/pubhtml')[1];
    }

    if(/spreadsheets\/d/.test(this.key)) {
      this.log('You passed the most recent version of Google Spreadsheets url as the key! Attempting to parse.');
      this.key = this.key.match('d\\/(.*?)\/')[1];
    }

    if (!this.key) {
      this.log('You need to pass Tabletop a key!');
      return;
    }

    this.log('Initializing with key ' + this.key);

    this.models = {};
    this.modelNames = [];
    this.model_names = this.modelNames; //jshint ignore:line

    this.baseJsonPath = '/feeds/worksheets/' + this.key + '/' + this.sheetPrivacy +'/basic?alt=';

    if (inNodeJS || supportsCORS) {
      this.baseJsonPath += 'json';
    } else {
      this.baseJsonPath += 'json-in-script';
    }

    if (this.authkey) {
      this.baseJsonPath += '&oauth_token=' + this.authkey;
    }

    if(!this.wait) {
      return this.fetch();
    }
  };

  // A global storage for callbacks.
  Tabletop.callbacks = {};

  // Backwards compatibility.
  Tabletop.init = function(options) {
    return new Tabletop(options);
  };

  Tabletop.sheets = function() {
    this.log('Times have changed! You\'ll want to use var tabletop = Tabletop.init(...); tabletop.sheets(...); instead of Tabletop.sheets(...)');
  };

  Tabletop.prototype = {

    fetch: function(callback) {
      var self = this;
      return new Promise(function(resolve, reject) {
        if (typeof(callback) !== 'undefined') {
          self.callback = callback;
        }
        if (!self.callback) {
          self.callback = resolve;
        }
        if (!self.error) {
          self.error = reject;
        }
        self.requestData(self.baseJsonPath, self.loadSheets);
      });
    },

    /*
      This will call the environment appropriate request method.

      In browser it will use JSON-P, in node it will use request()
    */
    requestData: function(path, callback) {
      this.log('Requesting', path);
      this.encounteredError = false;
      if (inNodeJS) {
        this.serverSideFetch(path, callback);
      } else {
        //CORS only works in IE8/9 across the same protocol
        //You must have your server on HTTPS to talk to Google, or it'll fall back on injection
        var protocol = this.endpoint.split('//').shift() || 'http';
        if (supportsCORS && (!inLegacyIE || protocol === location.protocol)) {
          this.xhrFetch(path, callback);
        } else {
          this.injectScript(path, callback);
        }
      }
    },

    /*
      Use Cross-Origin XMLHttpRequest to get the data in browsers that support it.
    */
    xhrFetch: function(path, callback) {
      //support IE8's separate cross-domain object
      var xhr = inLegacyIE ? new XDomainRequest() : new XMLHttpRequest();
      xhr.open('GET', this.endpoint + path);
      var self = this;
      xhr.onload = function() {
        var json;
        try {
          json = JSON.parse(xhr.responseText);
        } catch (e) {
          console.error(e);
        }
        callback.call(self, json);
      };
      if(this.error) {
        xhr.addEventListener('error', this.error);
      }
      xhr.send();
    },

    injectScript: function(path, callback) {
      var script = document.createElement('script');
      var callbackName;

      if (this.singleton) {
        if (callback === this.loadSheets) {
          callbackName = 'Tabletop.singleton.loadSheets';
        } else if (callback === this.loadSheet) {
          callbackName = 'Tabletop.singleton.loadSheet';
        }
      } else {
        var self = this;
        callbackName = 'tt' + (+new Date()) + (Math.floor(Math.random()*100000));
        Tabletop.callbacks[ callbackName ] = function () {
          var args = Array.prototype.slice.call( arguments, 0 );
          callback.apply(self, args);
          script.parentNode.removeChild(script);
          delete Tabletop.callbacks[callbackName];
        };
        callbackName = 'Tabletop.callbacks.' + callbackName;
      }

      var url = path + '&callback=' + callbackName;

      if (this.simpleUrl) {
        if(path.indexOf('/list/') !== -1) {
          script.src = this.endpoint + '/' + this.key + '-' + path.split('/')[4];
        } else {
          script.src = this.endpoint + '/' + this.key;
        }
      } else {
        script.src = this.endpoint + url;
      }

      if (this.parameterize) {
        script.src = this.parameterize + encodeURIComponent(script.src);
      }

      this.log('Injecting', script.src);

      document.getElementsByTagName('script')[0].parentNode.appendChild(script);
    },
    serverSideFetch: function(path, callback) {
      var self = this;

      this.log('Fetching', this.endpoint + path);
      request({url: this.endpoint + path, json: true}, function(err, resp, body) {
        if (err) {
          return console.error(err);
        }
        callback.call(self, body);
      });
    },
    isWanted: function(sheetName) {
      if (this.wanted.length === 0) {
        return true;
      } else {
        return (ttIndexOf(this.wanted, sheetName) !== -1);
      }
    },
    data: function() {
      if (this.modelNames.length === 0) {
        return undefined;
      }
      if (this.simpleSheet) {
        if (this.modelNames.length > 1 && this.debug) {
          this.log('WARNING You have more than one sheet but are using simple sheet mode! Don\'t blame me when something goes wrong.');
        }
        return this.models[this.modelNames[0]].all();
      } else {
        return this.models;
      }
    },
    addWanted: function(sheet) {
      if(ttIndexOf(this.wanted, sheet) === -1) {
        this.wanted.push(sheet);
      }
    },
    loadSheets: function(data) {
      var i, ilen;
      var toLoad = [];
      try {
        this.googleSheetName = data.feed.title.$t;
      } catch(err) {
        this.error(err);
        return;
      }
      this.foundSheetNames = [];

      for (i = 0, ilen = data.feed.entry.length; i < ilen ; i++) {
        this.foundSheetNames.push(data.feed.entry[i].title.$t);
        if (this.isWanted(data.feed.entry[i].content.$t)) {
          var linkIdx = data.feed.entry[i].link.length-1;
          var sheetId = data.feed.entry[i].link[linkIdx].href.split('/').pop();
          var jsonPath = '/feeds/list/' + this.key + '/' + sheetId + '/' + this.sheetPrivacy + '/values?alt=';
          if (inNodeJS || supportsCORS) {
            jsonPath += 'json';
          } else {
            jsonPath += 'json-in-script';
          }
          if (this.query) {
            jsonPath += '&tq=' + this.query;
          }
          if (this.orderby) {
            jsonPath += '&orderby=column:' + this.orderby.toLowerCase();
          }
          if (this.reverse) {
            jsonPath += '&reverse=true';
          }
          if (this.authkey) {
            jsonPath += '&oauth_token=' + this.authkey;
          }
          toLoad.push(jsonPath);
        }
      }

      this.sheetsToLoad = toLoad.length;
      for(i = 0, ilen = toLoad.length; i < ilen; i++) {
        this.requestData(toLoad[i], this.loadSheet);
      }
    },
    sheets: function(sheetName) {
      if (typeof sheetName === 'undefined') {
        return this.models;
      } else {
        if (typeof(this.models[sheetName]) === 'undefined') {
          return;
        } else {
          return this.models[sheetName];
        }
      }
    },

    sheetReady: function(model) {
      this.models[model.name] = model;
      if (ttIndexOf(this.modelNames, model.name) === -1) {
        this.modelNames.push(model.name);
      }

      this.sheetsToLoad--;
      if (this.sheetsToLoad === 0) {
        this.doCallback();
      }
    },
    loadSheet: function(data) {
      var that = this;
      new Tabletop.Model({
        data: data,
        parseNumbers: this.parseNumbers,
        postProcess: this.postProcess,
        tabletop: this,
        prettyColumnNames: this.prettyColumnNames,
        onReady: function() {
          that.sheetReady(this);
        }
      });
    },
    doCallback: function() {
      if(this.sheetsToLoad === 0) {
        this.callback.apply(this.callbackContext || this, [this.data(), this]);
      }
    },

    log: function() {
      if(this.debug) {
        if(typeof console !== 'undefined' && typeof console.log !== 'undefined') {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
    }

  };
  Tabletop.Model = function(options) {
    var i, j, ilen, jlen;
    this.columnNames = [];
    this.column_names = this.columnNames;
    this.name = options.data.feed.title.$t;
    this.tabletop = options.tabletop;
    this.elements = [];
    this.onReady = options.onReady;
    this.raw = options.data;

    if (typeof(options.data.feed.entry) === 'undefined') {
      options.tabletop.log('Missing data for ' + this.name + ', make sure you didn\'t forget column headers');
      this.originalColumns = [];
      this.elements = [];
      this.ready();
      return;
    }

    for (var key in options.data.feed.entry[0]){
      if (/^gsx/.test(key)) {
        this.columnNames.push(key.replace('gsx$',''));
      }
    }

    this.originalColumns = this.columnNames;
    this.original_columns = this.originalColumns;

    for (i = 0, ilen =  options.data.feed.entry.length ; i < ilen; i++) {
      var source = options.data.feed.entry[i];
      var element = {};
      for (j = 0, jlen = this.columnNames.length; j < jlen ; j++) {
        var cell = source['gsx$' + this.columnNames[j]];
        if (typeof(cell) !== 'undefined') {
          if (options.parseNumbers && cell.$t !== '' && !isNaN(cell.$t)) {
            element[this.columnNames[j]] = +cell.$t;
          } else {
            element[this.columnNames[j]] = cell.$t;
          }
        } else {
          element[this.columnNames[j]] = '';
        }
      }
      if (element.rowNumber === undefined) {
        element.rowNumber = i + 1;
      }

      this.elements.push(element);
    }

    if (options.prettyColumnNames) {
      this.fetchPrettyColumns();
    } else {
      this.ready();
    }
  };

  Tabletop.Model.prototype = {
    all: function() {
      return this.elements;
    },

    fetchPrettyColumns: function() {
      if (!this.raw.feed.link[3]) {
        return this.ready();
      }

      var cellurl = this.raw.feed.link[3].href.replace('/feeds/list/', '/feeds/cells/').replace('https://spreadsheets.google.com', '');
      var that = this;
      this.tabletop.requestData(cellurl, function(data) {
        that.loadPrettyColumns(data);
      });
    },

    beforeReady: function() {
      if(this.postProcess) {
        for (i = 0, ilen = this.elements.length; i < ilen; i++) {
          this.postProcess(element);
        }
      }
    },

    ready: function() {
      this.beforeReady();
      this.onReady.call(this);
    },
    loadPrettyColumns: function(data) {
      var prettyColumns = {};

      var columnNames = this.columnNames;

      var i = 0;
      var l = columnNames.length;

      for (; i < l; i++) {
        if (typeof data.feed.entry[i].content.$t !== 'undefined') {
          prettyColumns[columnNames[i]] = data.feed.entry[i].content.$t;
        } else {
          prettyColumns[columnNames[i]] = columnNames[i];
        }
      }

      this.prettyColumns = prettyColumns;
      this.pretty_columns = this.prettyColumns; // jshint ignore:line
      this.prettifyElements();
      this.ready();
    },
    prettifyElements: function() {
      var prettyElements = [],
          orderedPrettyNames = [],
          i, j, ilen, jlen;

      for (j = 0, jlen = this.columnNames.length; j < jlen ; j++) {
        orderedPrettyNames.push(this.prettyColumns[this.columnNames[j]]);
      }

      for (i = 0, ilen = this.elements.length; i < ilen; i++) {
        var newElement = {};
        for (j = 0, jlen = this.columnNames.length; j < jlen ; j++) {
          var newColumnName = this.prettyColumns[this.columnNames[j]];
          newElement[newColumnName] = this.elements[i][this.columnNames[j]];
        }
        prettyElements.push(newElement);
      }
      this.elements = prettyElements;
      this.columnNames = orderedPrettyNames;
    },
    toArray: function() {
      var array = [],
          i, j, ilen, jlen;
      for (i = 0, ilen = this.elements.length; i < ilen; i++) {
        var row = [];
        for (j = 0, jlen = this.columnNames.length; j < jlen ; j++) {
          row.push(this.elements[i][ this.columnNames[j]]);
        }
        array.push(row);
      }

      return array;
    }
  };

  if(typeof module !== 'undefined' && module.exports) {
    module.exports = Tabletop;
  } else if (typeof define === 'function' && define.amd) {
    define(function () {
      return Tabletop;
    });
  } else {
    window.Tabletop = Tabletop;
  }

})();

</script>



<script type="text/javascript">
  var public_spreadsheet_url = 'https://docs.google.com/spreadsheets/d/1kTFnCiuDAYVdpzNqVIgNKsSLKYK9tRR1Mxd6gjBncFU/pub?hl=en_US&hl=en_US&hl=en_US&output=html';

  function init() {
          Tabletop.init( { key: public_spreadsheet_url,
                           callback: showInfo,
                           simpleSheet: true } );
        }

        window.addEventListener('DOMContentLoaded', init)

        function showInfo(data) {
          var mNum = 1;
          var mProb = data[mNum].Name;
          var mAns = data[mNum].Answer;
          document.getElementById("math").innerHTML = [ mProb ].join(", ");
          document.getElementById("answer").innerHTML = [ mAns ].join(", ");
          console.log(data);
        }


  </script>

<script>

function compute() {

  var videoTime = parseInt(document.getElementById("vTime").innerHTML);
  if ((document.getElementById("fill").value == document.getElementById("answer").innerHTML)){        // logical condition
  videoTime += 30;
  document.getElementById("vTime").innerHTML = videoTime;
  document.getElementById('fill').value = "";

  var elem = document.getElementById("myAnimation");
  var arrayOfFuncs = [];
    arrayOfFuncs.push(function () { document.getElementById('myAnimation').style.backgroundImage="url(cookie.png)"; });
    arrayOfFuncs.push(function () { document.getElementById('myAnimation').style.backgroundImage="url(muffin.png)"; });
    arrayOfFuncs.push(function () { document.getElementById('myAnimation').style.backgroundImage="url(cake.png)"; });
  arrayOfFuncs[Math.floor(Math.random() * 3)]();

  elem.style.opacity = 1;
  var pos = 0;
  var id = setInterval(frame, 10);
  function frame() {
    if (pos >= 350) {
      clearInterval(id);
      elem.style.opacity = 0;
      elem.style.top = 0;
    } else {
      pos+=5;
      elem.style.top = pos + 'px';
    }
  }

  setTimeout(function() {
    function showInfo(data) {
      var mNum+=1;
      var mProb = data[mNum].Name;
      var mAns = data[mNum].Answer;
      document.getElementById("math").innerHTML = [ mProb ].join(", ");
      document.getElementById("answer").innerHTML = [ mAns ].join(", ");
      console.log(data);
    }
}, 300);
  }else{
    videoTime -= 1;
    document.getElementById("vTime").innerHTML = videoTime;
    document.getElementById('fill').value = "";
    var elem = document.getElementById("myAnimation2");
    elem.style.opacity = 1;
    var pos = 0;
    var id = setInterval(frame, 10);
    function frame() {
      if (pos >= 350) {
        clearInterval(id);
        elem.style.opacity = 0;
        elem.style.top = 0;
      } else {
        pos+=3;
        elem.style.top = pos + 'px';
      }
    }
  }
}

</script>


</html>
